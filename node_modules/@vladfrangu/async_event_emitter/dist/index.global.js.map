{"version":3,"sources":["../src/index.ts"],"sourcesContent":["function validateListener(input: unknown): asserts input is (...args: unknown[]) => Awaitable<void> {\n\tif (typeof input !== 'function') {\n\t\tthrow new TypeError(`The listener argument must be a function. Received ${typeof input}`);\n\t}\n}\n\n// Inspired from https://github.com/nodejs/node/blob/42ad967d68137df1a80a877e7b5ad56403fc157f/lib/internal/util.js#L397\nfunction spliceOne(list: unknown[], index: number) {\n\tfor (; index + 1 < list.length; index++) {\n\t\tlist[index] = list[index + 1];\n\t}\n\n\tlist.pop();\n}\n\n// Inspired from https://github.com/nodejs/node/blob/42ad967d68137df1a80a877e7b5ad56403fc157f/lib/events.js#L889\nfunction arrayClone<T extends unknown[]>(arr: T): T {\n\t// At least since V8 8.3, this implementation is faster than the previous\n\t// which always used a simple for-loop\n\tswitch (arr.length) {\n\t\tcase 2:\n\t\t\treturn [arr[0], arr[1]] as T;\n\t\tcase 3:\n\t\t\treturn [arr[0], arr[1], arr[2]] as T;\n\t\tcase 4:\n\t\t\treturn [arr[0], arr[1], arr[2], arr[3]] as T;\n\t\tcase 5:\n\t\t\treturn [arr[0], arr[1], arr[2], arr[3], arr[4]] as T;\n\t\tcase 6:\n\t\t\treturn [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]] as T;\n\t}\n\n\treturn arr.slice() as T;\n}\n\n// Inspired from https://github.com/nodejs/node/blob/42ad967d68137df1a80a877e7b5ad56403fc157f/lib/events.js#L427-L475\nfunction identicalSequenceRange(a: unknown[], b: unknown[]): [number, number] {\n\tfor (let i = 0; i < a.length - 3; i++) {\n\t\t// Find the first entry of b that matches the current entry of a.\n\t\tconst pos = b.indexOf(a[i]);\n\t\tif (pos !== -1) {\n\t\t\tconst rest = b.length - pos;\n\t\t\tif (rest > 3) {\n\t\t\t\tlet len = 1;\n\t\t\t\tconst maxLen = Math.min(a.length - i, rest);\n\t\t\t\t// Count the number of consecutive entries.\n\t\t\t\twhile (maxLen > len && a[i + len] === b[pos + len]) {\n\t\t\t\t\tlen++;\n\t\t\t\t}\n\t\t\t\tif (len > 3) {\n\t\t\t\t\treturn [len, i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [0, 0];\n}\n\nfunction enhanceStackTrace(this: AsyncEventEmitter<any>, err: Error, own: Error) {\n\tlet ctorInfo = '';\n\ttry {\n\t\tconst { name } = this.constructor;\n\t\tif (name !== 'AsyncEventEmitter') ctorInfo = ` on ${name} instance`;\n\t} catch {\n\t\t// Continue regardless of error.\n\t}\n\tconst sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n\tconst errStack = err.stack!.split('\\n').slice(1);\n\tconst ownStack = own.stack!.split('\\n').slice(1);\n\n\tconst { 0: len, 1: off } = identicalSequenceRange(ownStack, errStack);\n\tif (len > 0) {\n\t\townStack.splice(off + 1, len - 2, '    [... lines matching original stack trace ...]');\n\t}\n\n\treturn err.stack + sep + ownStack.join('\\n');\n}\n\ninterface InternalEventMap extends Array<StoredListener> {\n\t_hasWarnedAboutMaxListeners?: boolean;\n}\n\nexport class AsyncEventEmitter<\n\tEvents extends Record<string | symbol, unknown[]> = Record<string | symbol, unknown[]> & AsyncEventEmitterPredefinedEvents\n> {\n\tprivate _events: Record<keyof Events | keyof AsyncEventEmitterPredefinedEvents, InternalEventMap> = Object.create(null);\n\tprivate _eventCount = 0;\n\tprivate _maxListeners = 10;\n\tprivate _internalPromiseMap: Record<string, Promise<void>> = Object.create(null);\n\tprivate _wrapperId = 0n;\n\n\tpublic addListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\tvalidateListener(listener);\n\n\t\tconst wrapped = this.#_wrapListener(eventName, listener, false);\n\n\t\tthis.#_addListener(eventName, wrapped, false);\n\n\t\treturn this;\n\t}\n\n\tpublic on<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\treturn this.addListener(eventName, listener);\n\t}\n\n\tpublic once<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\tvalidateListener(listener);\n\n\t\tconst wrapped = this.#_wrapListener(eventName, listener, true);\n\n\t\tthis.#_addListener(eventName, wrapped, false);\n\n\t\treturn this;\n\t}\n\n\tpublic removeListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\tvalidateListener(listener);\n\n\t\tconst eventList = this._events[eventName];\n\n\t\tif (eventList === undefined) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet position = -1;\n\n\t\tfor (let i = eventList.length - 1; i >= 0; i--) {\n\t\t\tif (eventList[i].listener === listener) {\n\t\t\t\tposition = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (position < 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (position === 0) {\n\t\t\teventList.shift();\n\t\t} else {\n\t\t\tspliceOne(eventList, position);\n\t\t}\n\n\t\tif (eventList.length === 0) {\n\t\t\tdelete this._events[eventName];\n\t\t\t--this._eventCount;\n\t\t}\n\n\t\tif (this._events.removeListener !== undefined) {\n\t\t\t// Thanks TypeScript for the cast...\n\t\t\tthis.emit('removeListener', eventName as string | symbol, listener);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tpublic off<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\treturn this.removeListener(eventName, listener);\n\t}\n\n\tpublic removeAllListeners<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(event?: K | undefined): this {\n\t\t// Not listening for removeListener, no need to emit\n\t\tif (this._events.removeListener === undefined) {\n\t\t\tif (!event) {\n\t\t\t\tthis._events = Object.create(null);\n\t\t\t} else if (this._events[event] !== undefined) {\n\t\t\t\tif (--this._eventCount === 0) {\n\t\t\t\t\tthis._events = Object.create(null);\n\t\t\t\t} else {\n\t\t\t\t\tdelete this._events[event];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\t// Emit removeListener for all listeners on all events\n\t\tif (!event) {\n\t\t\tfor (const key of Reflect.ownKeys(this._events)) {\n\t\t\t\tif (key === 'removeListener') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis.removeAllListeners(key);\n\t\t\t}\n\n\t\t\tthis.removeAllListeners('removeListener');\n\t\t\tthis._events = Object.create(null);\n\t\t\tthis._eventCount = 0;\n\n\t\t\treturn this;\n\t\t}\n\n\t\tconst listeners = this._events[event];\n\n\t\tif (listeners !== undefined) {\n\t\t\t// LIFO order\n\t\t\tfor (let i = listeners.length - 1; i >= 0; i--) {\n\t\t\t\tthis.removeListener(event, listeners[i].listener);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tpublic setMaxListeners(n: number): this {\n\t\tif (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {\n\t\t\tthrow new RangeError(`Expected to get a non-negative number for \"setMaxListeners\", got ${n} instead`);\n\t\t}\n\n\t\tthis._maxListeners = n;\n\n\t\treturn this;\n\t}\n\n\tpublic getMaxListeners(): number {\n\t\treturn this._maxListeners;\n\t}\n\n\tpublic listeners<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K\n\t): StoredListener<Events[keyof Events]>['listener'][] {\n\t\tconst eventList = this._events[eventName];\n\n\t\tif (eventList === undefined) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn eventList.map(({ listener }) => listener);\n\t}\n\n\tpublic rawListeners<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K): StoredListener<Events[keyof Events]>[] {\n\t\tconst eventList = this._events[eventName];\n\n\t\tif (eventList === undefined) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn arrayClone(eventList);\n\t}\n\n\tpublic emit<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\t...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]\n\t): boolean {\n\t\tconst doError = eventName === 'error' && this._events.error === undefined;\n\n\t\tif (doError) {\n\t\t\tlet er: unknown;\n\n\t\t\tif (args.length > 0) {\n\t\t\t\t// eslint-disable-next-line prefer-destructuring\n\t\t\t\ter = args[0];\n\t\t\t}\n\n\t\t\tif (er instanceof Error) {\n\t\t\t\ttry {\n\t\t\t\t\tconst capture = {};\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\t\t\tError.captureStackTrace(capture, AsyncEventEmitter.prototype.emit);\n\t\t\t\t\tObject.defineProperty(er, 'stack', {\n\t\t\t\t\t\tvalue: enhanceStackTrace.call(this, er, capture as Error),\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\t\t\t\t} catch {\n\t\t\t\t\t// Continue regardless of error\n\t\t\t\t}\n\n\t\t\t\tthrow er; // Unhandled 'error' event\n\t\t\t}\n\n\t\t\tconst stringifiedError = String(er);\n\n\t\t\t// Give some error to user\n\t\t\tconst err = new Error(`Unhandled 'error' event emitted, received ${stringifiedError}`);\n\t\t\t// @ts-expect-error Add context to error too\n\t\t\terr.context = er;\n\n\t\t\tthrow err; // Unhandled 'error' event\n\t\t}\n\n\t\tconst handlers = this._events[eventName];\n\n\t\tif (handlers === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst len = handlers.length;\n\t\tconst listeners = arrayClone(handlers);\n\n\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t// We call all listeners regardless of the result, as we already handle possible error emits in the wrapped func\n\t\t\tvoid listeners[i].wrappedFunc(...args);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic listenerCount<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K): number {\n\t\treturn this._eventCount > 0 ? this._events[eventName]?.length ?? 0 : 0;\n\t}\n\n\tpublic prependListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\tvalidateListener(listener);\n\n\t\tconst wrapped = this.#_wrapListener(eventName, listener, false);\n\n\t\tthis.#_addListener(eventName, wrapped, true);\n\n\t\treturn this;\n\t}\n\n\tpublic prependOnceListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\tvalidateListener(listener);\n\n\t\tconst wrapped = this.#_wrapListener(eventName, listener, true);\n\n\t\tthis.#_addListener(eventName, wrapped, true);\n\n\t\treturn this;\n\t}\n\n\tpublic eventNames(): (keyof Events | keyof AsyncEventEmitterPredefinedEvents)[] {\n\t\treturn this._eventCount > 0 ? Reflect.ownKeys(this._events) : [];\n\t}\n\n\tpublic async waitForAllListenersToComplete() {\n\t\tconst promises = Object.values(this._internalPromiseMap);\n\n\t\tif (promises.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tawait Promise.all(promises);\n\n\t\treturn true;\n\t}\n\n\t#_addListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K, wrappedListener: StoredListener, prepend: boolean) {\n\t\t// Emit newListener first in the event someone is listening for it\n\t\tif (this._events.newListener !== undefined) {\n\t\t\t// Thanks TypeScript for the cast...\n\t\t\tthis.emit('newListener', eventName as string | symbol, wrappedListener.listener);\n\t\t}\n\n\t\tlet existing = this._events[eventName];\n\n\t\tif (existing === undefined) {\n\t\t\t// eslint-disable-next-line no-multi-assign\n\t\t\texisting = this._events[eventName] = [wrappedListener];\n\t\t\tthis._eventCount++;\n\t\t} else if (prepend) {\n\t\t\texisting.unshift(wrappedListener);\n\t\t} else {\n\t\t\texisting.push(wrappedListener);\n\t\t}\n\n\t\tif (this._maxListeners > 0 && existing.length > this._maxListeners && !existing._hasWarnedAboutMaxListeners) {\n\t\t\texisting._hasWarnedAboutMaxListeners = true;\n\t\t\tconst warningMessage = [\n\t\t\t\t`Possible AsyncEventEmitter memory leak detected. ${existing.length} ${String(eventName)} listeners added to ${\n\t\t\t\t\tthis.constructor.name\n\t\t\t\t}.`,\n\t\t\t\t`Use emitter.setMaxListeners() to increase the limit.`\n\t\t\t].join(' ');\n\t\t\tconsole.warn(warningMessage, this);\n\t\t}\n\t}\n\n\t#_wrapListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void,\n\t\tonce: boolean\n\t) {\n\t\tconst state = {\n\t\t\tfired: false,\n\t\t\tlistener,\n\t\t\teventEmitter: this,\n\t\t\tonce\n\t\t} as unknown as StoredListener;\n\n\t\tconst wrappedFn = async (...args: any[]) => {\n\t\t\tif (state.once && state.fired) {\n\t\t\t\t// Prevent execution if this listener is meant to be ran only once and it was already ran\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Remove the listener to prevent subsequent executions\n\t\t\tif (state.once) {\n\t\t\t\tstate.fired = true;\n\t\t\t\tstate.eventEmitter.removeListener(eventName, listener);\n\t\t\t}\n\n\t\t\tconst promiseId = String(this._wrapperId++);\n\n\t\t\tconst promise = new Promise<void>(async (res) => {\n\t\t\t\ttry {\n\t\t\t\t\t// Execute the actual listener\n\t\t\t\t\tif (args.length === 0) {\n\t\t\t\t\t\tawait state.listener.call(this);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tawait state.listener.apply(this, args);\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// Emit the error event\n\t\t\t\t\tstate.eventEmitter.emit('error', err);\n\t\t\t\t} finally {\n\t\t\t\t\t// Resolve the internal promise\n\t\t\t\t\tres();\n\n\t\t\t\t\tdelete this._internalPromiseMap[promiseId];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._internalPromiseMap[promiseId] = promise;\n\n\t\t\tawait promise;\n\t\t};\n\n\t\tstate.wrappedFunc = wrappedFn;\n\n\t\treturn state;\n\t}\n}\n\nexport interface AsyncEventEmitterPredefinedEvents {\n\tnewListener: [eventName: string | symbol, listener: (...args: any[]) => Awaitable<void>];\n\tremoveListener: [eventName: string | symbol, listener: (...args: any[]) => Awaitable<void>];\n\terror: [error: unknown];\n}\n\nexport interface StoredListener<Args extends any[] = any[]> {\n\twrappedFunc: (...args: Args) => Promise<void>;\n\tlistener: (...args: Args) => Awaitable<void>;\n\tfired: boolean;\n\tonce: boolean;\n\teventName: string | symbol;\n\teventEmitter: AsyncEventEmitter<any>;\n}\n\nexport type Awaitable<T> = T | Promise<T>;\n"],"mappings":"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","names":[]}