declare class AsyncEventEmitter<Events extends Record<string | symbol, unknown[]> = Record<string | symbol, unknown[]> & AsyncEventEmitterPredefinedEvents> {
    #private;
    private _events;
    private _eventCount;
    private _maxListeners;
    private _internalPromiseMap;
    private _wrapperId;
    addListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K, listener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void): this;
    on<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K, listener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void): this;
    once<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K, listener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void): this;
    removeListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K, listener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void): this;
    off<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K, listener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void): this;
    removeAllListeners<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(event?: K | undefined): this;
    setMaxListeners(n: number): this;
    getMaxListeners(): number;
    listeners<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K): StoredListener<Events[keyof Events]>['listener'][];
    rawListeners<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K): StoredListener<Events[keyof Events]>[];
    emit<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K, ...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]): boolean;
    listenerCount<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K): number;
    prependListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K, listener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void): this;
    prependOnceListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K, listener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void): this;
    eventNames(): (keyof Events | keyof AsyncEventEmitterPredefinedEvents)[];
    waitForAllListenersToComplete(): Promise<boolean>;
}
interface AsyncEventEmitterPredefinedEvents {
    newListener: [eventName: string | symbol, listener: (...args: any[]) => Awaitable<void>];
    removeListener: [eventName: string | symbol, listener: (...args: any[]) => Awaitable<void>];
    error: [error: unknown];
}
interface StoredListener<Args extends any[] = any[]> {
    wrappedFunc: (...args: Args) => Promise<void>;
    listener: (...args: Args) => Awaitable<void>;
    fired: boolean;
    once: boolean;
    eventName: string | symbol;
    eventEmitter: AsyncEventEmitter<any>;
}
declare type Awaitable<T> = T | Promise<T>;

export { AsyncEventEmitter, AsyncEventEmitterPredefinedEvents, Awaitable, StoredListener };
